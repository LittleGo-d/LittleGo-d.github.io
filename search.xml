<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>爬楼梯</title>
    <url>/2023/03/09/LeetCode_70/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>动态规划：</strong></p>
<image src="http://rr9ei3yvu.hn-bkt.clouddn.com/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84.gif">

<span id="more"></span>

<p>我们用f(a）表示爬到第·级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以<br>我们可以列出如下式子<br>f(a）= f(a -1)＋ f(a一2)<br>它意味着爬到第a级台阶的方案数是爬到第 -1级台阶的方案数和爬到第 a-2级台阶的方案数的和。很<br>好理解，因为每次只能爬1级或2级，所以f(a）只能从f(a -1）和f(a -2）转移过来，而这里要统计方案<br>总数，我们就需要对这两项的贡献求和<br>以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第0级开始爬的，所以从第0级爬到第0级我们可以看作只有一种方案，即f(0) =1；从第0级到第1级也只有一种方案，即爬一级，f(1)=1。这两个作为边界条件就可以继续向后推导出第n级的正确结果。我们不妨写几项来验证一下，根据转移方程得到f(2)= 2，f(3)= 3，f(4)= 5，..….…，我们把这些情况都枚举出来，发现计算的结果是正确的<br>我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是O(n）的实现，但是由于这里的f(a）只和f(a -1)与f(a-2）有关，所以我们可以用「滚动数组思想」把空间复杂度优化成O(1)。下面的<br>代码中给出的就是这种实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</image>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>乌拉</title>
    <url>/2022/12/31/%E4%B9%8C%E6%8B%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="乌拉，小站建成！🐖"><a href="#乌拉，小站建成！🐖" class="headerlink" title="乌拉，小站建成！🐖"></a>乌拉，小站建成！🐖</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="110" src="//music.163.com/outchain/player?type=2&id=1366467511&auto=0&height=90"></iframe>
]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2023/03/10/%E6%9C%80%E5%A4%A7%E5%82%A8%E6%B0%B4%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>动态规划：</strong></p>
<image src="http://rr9ei3yvu.hn-bkt.clouddn.com/%E6%9C%80%E5%A4%A7%E5%82%A8%E6%B0%B4%E9%87%8F.png">

<span id="more"></span>

<p>**双指针    **</p>
<p>分别指向数组的两端，每次都把更小的向中间移动一个，并更新最大值，直到指针相遇，循环结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">//容量就是底乘高  底就是索引之差，高度就是两者之间较小的那个</span></span><br><span class="line">        <span class="comment">//双指针 分别在数组两端，每次将更小的向内移动，每次更新最大值，知道两指针相遇，循环结束</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tem</span> <span class="operator">=</span> Math.min(height[p2],height[p1]) * (p2 - p1);</span><br><span class="line">            <span class="keyword">if</span>(tem &gt; area)&#123;</span><br><span class="line">                area = tem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt;= height[p2])&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</image>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
