<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="/2022/12/26/jvm/"/>
    <url>/2022/12/26/jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221223194804150.png" alt="image-20221223194804150"></p><p>定义</p><p>Porgram Counter Register程序计数器（物理上通过寄存器实现）</p><ul><li>作用：记住下一条jvm指令的执行地址</li><li>特点<ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul></li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>定义</p><p>Java Virtual Machine Stachs（全称：java虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，成为虚拟机栈</li><li>每个栈有多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><p>问题辨析：</p><p>​    1.垃圾回收是否涉及栈内存？</p><p>​        -不会，栈内存是方法运行时所占用的内存，方法运行结束会自行释放，不需要垃圾回收机制管理</p><p>​    2.栈内存分配越大越好吗？</p><p>​        -并不是，栈内存如果过大反而会使线程运行数目变少</p><p>​    3.方法内的局部变量是否线程安全？</p><p>​        -如果该变量没有逃离方法的作用范围，则线程安全，反之，需要考虑线程安全问题</p><p>栈内存溢出：</p><ul><li>栈帧过多导致溢出</li><li>栈帧过大导致溢出</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>给本地方法的运行提供运行的空间</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>定义</p><p>Heap堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><h3 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a><strong>堆内存诊断</strong></h3><ul><li>jps 工具</li></ul><p>查看当前系统中有哪些 java 进程</p><ul><li>jmap 工具</li></ul><p>查看堆内存占用情况 jmap - heap 进程id</p><ul><li>jconsole 工具</li></ul><p>图形界面的，多功能的监测工具，可以连续监测</p><p>​    案例</p><p>垃圾回收后，内存占用仍然很高</p><p>​    -可以配合jvisualvm查看堆内存详细信息判断问题</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221224152559505.png" alt="image-20221224152559505"></p><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221224152614501.png" alt="image-20221224152614501"></p><p>方法区内存溢出</p><ul><li><p>1.8 以前会导致永久代内存溢出、</p><ul><li>演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space </li><li>-XX:MaxPermSize=8m</li></ul></li><li><p>1.8 之后会导致元空间内存溢出</p><ul><li>演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace </li><li>-XX:MaxMetaspaceSize=8m</li></ul></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量</li></ul><p>等信息</p><ul><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量</li></ul><p>池，并把里面的符号地址变为真实地址</p><h3 id="StringTable-特性"><a href="#StringTable-特性" class="headerlink" title="StringTable 特性"></a><strong>StringTable</strong> <strong>特性</strong></h3><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是 StringBuilder （1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，</li></ul></li></ul><p>​               放入串池， 会把串池中的对象返回</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>定义</p><p>Direct Memory</p><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h3><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><p>1.引用计数法</p><p>2.可达性分析算法</p><ul><li><p>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以</p><p>回收</p></li></ul><h2 id="几种引用"><a href="#几种引用" class="headerlink" title="几种引用"></a>几种引用</h2><ol><li>强引用</li></ol><ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul><ol start="2"><li>软引用（SoftReference）</li></ol><ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul><ol start="3"><li>弱引用（WeakReference）</li></ol><ul><li><p>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</p></li><li><p>可以配合引用队列来释放弱引用自身</p></li></ul><ol start="4"><li>虚引用（PhantomReference）</li></ol><ul><li><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，</p><p>由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li></ul><ol start="5"><li>终结器引用（FinalReference）</li></ol><ul><li><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象</p><p>暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 fifinalize</p><p>方法，第二次 GC 时才能回收被引用对象</p></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1、标记清除"><a href="#1、标记清除" class="headerlink" title="1、标记清除"></a>1、标记清除</h3><p>定义：Mark Sweep</p><ul><li>速度较快</li><li>会造成内存碎片</li></ul><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221225155320173.png" alt="image-20221225155320173"></p><h3 id="2、标记整理"><a href="#2、标记整理" class="headerlink" title="2、标记整理"></a>2、标记整理</h3><p>定义：Mark Compact</p><ul><li>速度慢</li><li>没有内存碎片</li></ul><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221225155353733.png" alt="image-20221225155353733"></p><h3 id="3、复制"><a href="#3、复制" class="headerlink" title="3、复制"></a>3、复制</h3><p>定义：Copy</p><ul><li>不会有内存碎片</li><li>需要占用双倍内存空间</li></ul><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221225155438032.png" alt="image-20221225155438032"></p><h2 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h2><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221225155641490.png" alt="image-20221225155641490"></p><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长</li></ul><h3 id="相关vm参数"><a href="#相关vm参数" class="headerlink" title="相关vm参数"></a>相关vm参数</h3><p><img src="C:\Users\20247\AppData\Roaming\Typora\typora-user-images\image-20221225155745122.png" alt="image-20221225155745122"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/25/hello-world/"/>
    <url>/2022/12/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
